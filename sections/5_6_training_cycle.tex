\section{Training cycle}\label{sec:training-cycle}
In this section, we will present the training cycle used to train the network.
The whole project is divided into three phases:
\begin{enumerate}
    \item Training;
    \item Validation;
    \item Testing.
\end{enumerate}
In the \textit{main.py} file there is a class called \textit{Main} that contains three main methods, one for each phase.

In the \textit{\_\_init\_\_} method, we initialize the network, the optimizer, the loss function, the dataset, the dataloader, log-writer, schedulers, and other smaller components.
Each time we start a training, we create a new folder for that run, and we save a copy the configuration file which contains all the parameters used in that run.

\subsection{Training and validation}\label{subsec:training}
At the beginning we print all the parameters used in that run, and we start the training cycle.
We start by loading the dataset and the dataloader, then, the training cycle, which iterates for a certain number of epochs, and for each epoch, we iterate over the dataset through dataloader.

For each epoch, the network is trained on the whole dataset, and the training loss is computed.
Then, we validate the network on the validation dataset, and we compute the validation loss.
At the end of each epoch, if the validation loss is lower than the previous epoch's one we save the network weights, the optimizer state, the scheduler state, and we log the learning rate, the training loss, validation loss, and we plot the trajectory predicted during the validation.

\subsection{Testing}\label{subsec:testing}

For the testing, the process is pretty much the same, with only difference that the testing dataloader does \textbf{NOT} shuffle the data.
It plots the trajectory predicted by the network, and it computes the loss on the testing dataset.
Then, it evaluates the network prediction by computing the \textbf{RPE} and \textbf{ATE} metrics.